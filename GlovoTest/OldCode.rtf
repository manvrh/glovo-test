{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 AppleColorEmoji;
}
{\colortbl;\red255\green255\blue255;\red255\green255\blue255;\red0\green0\blue0;\red219\green0\blue130;
\red92\green38\blue153;\red138\green9\blue225;\red28\green0\blue207;\red38\green71\blue75;\red0\green116\blue0;
\red217\green5\blue0;\red46\green13\blue110;}
{\*\expandedcolortbl;;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c0\c0\c0;\csgenericrgb\c86010\c0\c51153;
\csgenericrgb\c35900\c14900\c60100;\csgenericrgb\c54046\c3473\c88041;\csgenericrgb\c11000\c0\c81000;\csgenericrgb\c14900\c27800\c29400;\csgenericrgb\c0\c45600\c0;
\csgenericrgb\c85249\c1994\c0;\csgenericrgb\c18100\c5200\c43100;}
\paperw11900\paperh16840\margl1440\margr1440\vieww19580\viewh14220\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb2 \
\pard\tx642\pardeftab642\pardirnatural\partightenfactor0

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \cf4 func\cf3  setupAddress(pick: \cf5 Bool\cf3  = \cf4 false\cf3 )\{
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf6 UIView\cf3 .animate(withDuration: \cf7 0.01\cf3 , animations: \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 \ulth \ulc4 s\ulnone elf\cf3 .mapStack.isHidden = \cf4 false
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \})
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \ulth m\ulnone ap = \cf6 MKMapView\cf3 ()
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \ulth m\ulnone ap.mapType = .standard
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \ulth m\ulnone ap.delegate = \cf4 self
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \ulth m\ulnone ap.showsUserLocation = \cf4 true
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 \ulth s\ulnone elf\cf3 .inputsStack.alpha = \cf7 0.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \ulth m\ulnone ap.alpha = \cf7 0.02
\f0\fs24 \cf0 \

\f1\fs26 \cf3         (\cf4 self\cf3 .mapView.subviews[\cf7 0\cf3 ] \cf4 as\cf3 ! \cf6 UIStackView\cf3 ).addArrangedSubview(\ulth m\ulnone ap)
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf6 UIView\cf3 .animate(withDuration: \cf7 0.1\cf3 , delay: \cf7 0.1\cf3 , options: [], animations: \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 \ulth s\ulnone elf\cf3 .inputsStack.alpha = \cf7 1.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}, completion: \cf4 nil\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf6 UIView\cf3 .animate(withDuration: \cf7 0.2\cf3 , delay: \cf7 0.7\cf3 , options: [], animations: \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 \ulth s\ulnone elf\cf3 .map.alpha = \cf7 1.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}, completion: \cf4 nil\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  pick = \cf4 true
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 \ulth s\ulnone elf\cf3 .nextButton.superview!.isHidden = \cf4 true
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 if\cf3  pick \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 self\cf3 .\cf8 putPins\cf3 ()
\f0\fs24 \cf0 \

\f1\fs26 \cf3             
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf9 /*
\f0\fs24 \cf0 \

\f1\fs26 \cf9          if pick == false  \{
\f0\fs24 \cf0 \

\f1\fs26 \cf9          
\f0\fs24 \cf0 \

\f1\fs26 \cf9          self.locationPressed(false)
\f0\fs24 \cf0 \

\f1\fs26 \cf9          delay(0.1)\{
\f0\fs24 \cf0 \

\f1\fs26 \cf9          self.locationManager.requestWhenInUseAuthorization()
\f0\fs24 \cf0 \

\f1\fs26 \cf9          \}
\f0\fs24 \cf0 \

\f1\fs26 \cf9          delay(0.2)\{
\f0\fs24 \cf0 \

\f1\fs26 \cf9          self.locationPressed(false)
\f0\fs24 \cf0 \

\f1\fs26 \cf9          \}
\f0\fs24 \cf0 \

\f1\fs26 \cf9          delay(0.4)\{
\f0\fs24 \cf0 \

\f1\fs26 \cf9          self.locationPressed(false)
\f0\fs24 \cf0 \

\f1\fs26 \cf9          \}
\f0\fs24 \cf0 \

\f1\fs26 \cf9          \}*/
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \cf4 func\cf3  putPins()\{
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \ulth z\ulnone oomInLabel.backgroundColor = \cf6 UIColor\cf3 .white.withAlphaComponent(\cf7 0.8\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \ulth z\ulnone oomInLabel.layer.cornerRadius = \cf7 10.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \ulth z\ulnone oomInLabel.layer.masksToBounds = \cf4 true
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \ulth m\ulnone apPin.isHidden = \cf4 true
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \ulth l\ulnone ocations = generateLocations()
\f0\fs24 \cf0 \

\f1\fs26 \cf3         print(\ulth l\ulnone ocations)
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 var\cf3  pointAnnotations = [\cf5 MKAnnotation\cf3 ]()
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 var\cf3  minLon = \cf7 10000.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 var\cf3  maxLon = \cf7 -10000.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 var\cf3  minLat = \cf7 10000.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 var\cf3  maxLat = \cf7 -10000.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 for\cf3  (index, location) \cf4 in\cf3  \ulth l\ulnone ocations.enumerated() \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  pa = MKPointAnnotation()
\f0\fs24 \cf0 \

\f1\fs26 \cf3             pa.coordinate = location
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  loc = CLLocationCoordinate2D(latitude: location.latitude + \cf7 1000.0\cf3 , longitude: location.longitude + \cf7 1000.0\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 if\cf3  loc.latitude < minLat \{ minLat = loc.latitude \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 if\cf3  loc.latitude > maxLat \{ maxLat = loc.latitude \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 if\cf3  loc.longitude < minLon \{ minLon = loc.longitude \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 if\cf3  loc.longitude > maxLon \{ maxLon = loc.longitude \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf9 //pa.title = String.init(format: "Pin: %.4f, %.4f", arguments: [location.latitude, location.longitude])
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  stores = [\cf10 "Diputacio"\cf3 , \cf10 "Consell de Cent"\cf3 , \cf10 "Arrag\'f3"\cf3 , \cf10 "Valencia"\cf3 , \cf10 "Paris"\cf3 , \cf10 "Londres"\cf3 , \cf10 "Comte Urgell"\cf3 , \cf10 "Villarroel"\cf3 , \cf10 "Arribau"\cf3 , \cf10 "Muntaner"\cf3 , \cf10 "Casanova"\cf3 , \cf10 "Comte Borell"\cf3 , \cf10 "Balmes"\cf3 , \cf10 "Viladomar"\cf3 , \cf10 "Sepulveda"\cf3 , \cf10 "Roger de Flor"\cf3 , \cf10 "Tetuan"\cf3 ]
\f0\fs24 \cf0 \

\f1\fs26 \cf3             pa.title = \cf10 "LP \cf3 \\\cf10 (\cf3 stores[index%\cf7 17\cf3 ]\cf10 ) \cf3 \\\cf10 (\cf3 Int(arc4random()%\cf7 300\cf3 +\cf7 40\cf3 )\cf10 )"
\f0\fs24 \cf0 \

\f1\fs26 \cf3             pointAnnotations.append(pa)
\f0\fs24 \cf0 \

\f1\fs26 \cf3             
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         minLon -= \cf7 1000.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         maxLon -= \cf7 1000.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         minLat -= \cf7 1000.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         maxLat -= \cf7 1000.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  latD = \cf11 fabs\cf3 (minLat-maxLat)
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  lonD = \cf11 fabs\cf3 (minLon-maxLon)
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  moreZoom = \cf7 1.2
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  center = \cf5 CLLocationCoordinate2D\cf3 .\cf6 init\cf3 (latitude: (maxLat+minLat)/\cf7 2\cf3 , longitude: (maxLon+minLon)/\cf7 2\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  newSpan = \cf5 MKCoordinateSpan\cf3 (latitudeDelta: latD*moreZoom, longitudeDelta: lonD*moreZoom)
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  newRegion = \cf5 MKCoordinateRegion\cf3 (center: center, span: newSpan)
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \ulth m\ulnone ap.addAnnotations(pointAnnotations)
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 \ulth s\ulnone elf\cf3 .map.setRegion(newRegion, animated: \cf4 false\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \cf4 func\cf3  generateLocations() -> [\cf5 CLLocationCoordinate2D\cf3 ]\{
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  lat = \cf7 41.388991
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  lon = \cf7 2.156212
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf9 //41.388991, 2.156212
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 var\cf3  randomCoordinates = [\cf7 0.0\cf3 ]
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  maxAdd = \cf7 0.40
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  repetition = \cf7 500.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  maxAddPerRepetition = maxAdd/repetition
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  chance = \cf7 1
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  points = \cf7 20
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 for\cf3  \cf4 _\cf3  \cf4 in\cf3  \cf7 1\cf3  ... points \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 var\cf3  newOffset = \cf7 0.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 for\cf3  \cf4 _\cf3  \cf4 in\cf3  \cf7 1\cf3  ... \cf5 Int\cf3 (repetition) \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf4 let\cf3  rand = \cf11 arc4random\cf3 ()%\cf7 100
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf4 if\cf3  rand < chance \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3                     \cf4 break
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 newOffset += \cf11 arc4random\cf3 ()%\cf7 2\cf3  == \cf7 0\cf3  ? -maxAddPerRepetition : maxAddPerRepetition
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3             randomCoordinates.\cf11 append\cf3 (newOffset)
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf9 //print(String.init(format: "%.4f", arguments: [newOffset]))
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 var\cf3  coordinates = [\cf5 CLLocationCoordinate2D\cf3 ]()
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf9 //var printString = ""
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 for\cf3  index \cf4 in\cf3  \cf7 0\cf3  ..< points/\cf7 2\cf3  \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  lo = lon + randomCoordinates[index*\cf7 2\cf3 ]
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  la = lat + randomCoordinates[index*\cf7 2\cf3 +\cf7 1\cf3 ]
\f0\fs24 \cf0 \

\f1\fs26 \cf3             coordinates.\cf11 append\cf3 (\cf5 CLLocationCoordinate2D\cf3 (latitude: la, longitude: lo))
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf9 /*let las = String.init(format: "%.5f", arguments: [la])
\f0\fs24 \cf0 \

\f1\fs26 \cf9              let los = String.init(format: "%.5f", arguments: [lo])
\f0\fs24 \cf0 \

\f1\fs26 \cf9              printString += las+", "+los*/
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf9 //print(printString)
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 return\cf3  coordinates
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \cf4 func\cf3  mapView(\cf4 _\cf3  mapView: \cf6 MKMapView\cf3 , viewFor annotation: \cf5 MKAnnotation\cf3 ) -> \cf6 MKAnnotationView\cf3 ? \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 if\cf3  \cf4 #available\cf3 (\cf4 iOS\cf3  \cf7 11.0\cf3 , *) \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf9 //guard let annotation = annotation as? EkoMarker else \{ return nil \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf9 // 3
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  t = annotation.title!!
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 if\cf3  !t.\cf11 contains\cf3 (\cf10 "LP"\cf3 ) \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf11 print\cf3 (\cf10 "unknown pin!"\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf4 let\cf3  view = \cf6 MKMarkerAnnotationView\cf3 (annotation: annotation, reuseIdentifier: \cf10 "My Location"\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf9 //view.canShowCallout = true
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 view.\cf5 tintColor\cf3  =  colorLiteral(red: 0.2493239412, green: 0.818543633, blue: 1, alpha: 1)
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 view.\cf5 markerTintColor\cf3  = \cf4 self\cf3 .\cf5 view\cf3 .\cf5 tintColor
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 view.\cf5 calloutOffset\cf3  = \cf5 CGPoint\cf3 (x: \cf7 0\cf3 , y: \cf7 0\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 view.\cf5 glyphText\cf3  = \cf10 "\'95"
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf9 //view.rightCalloutAccessoryView = UIButton(type: .detailDisclosure)
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf4 return\cf3  view
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  identifier = \cf10 "marker"
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 var\cf3  view: \cf6 MKMarkerAnnotationView
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf9 // 4
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 if\cf3  \cf4 let\cf3  dequeuedView = mapView.\cf11 dequeueReusableAnnotationView\cf3 (withIdentifier: identifier)
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf4 as\cf3 ? \cf6 MKMarkerAnnotationView\cf3  \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 dequeuedView.\cf5 annotation\cf3  = annotation
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 view = dequeuedView
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \} \cf4 else\cf3  \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf9 // 5
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 view = \cf6 MKMarkerAnnotationView\cf3 (annotation: annotation, reuseIdentifier: identifier)
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf9 //view.canShowCallout = true
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 view.\cf5 tintColor\cf3  = \cf4 self\cf3 .\cf5 view\cf3 .\cf5 tintColor
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 view.\cf5 markerTintColor\cf3  = \cf4 self\cf3 .\cf5 view\cf3 .\cf5 tintColor
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 view.\cf5 calloutOffset\cf3  = \cf5 CGPoint\cf3 (x: \cf7 0\cf3 , y: \cf7 0\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 view.glyphImage = \ulth E\ulnone ko.image(named: \cf10 "shopping"\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 view.\cf5 rightCalloutAccessoryView\cf3  = \cf6 UIButton\cf3 (type: .\cf11 detailDisclosure\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 \ulth s\ulnone elf\cf3 .mapAnnotationViews.append(view)
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 return\cf3  view
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \} \cf4 else\cf3  \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  view = \cf6 MKPinAnnotationView\cf3 (annotation: annotation, reuseIdentifier: \cf10 "pin"\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3             view.\cf5 pinTintColor\cf3  = \cf4 self\cf3 .\cf5 view\cf3 .\cf5 tintColor
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 \ulth s\ulnone elf\cf3 .mapAnnotationViews.append(view)
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 return\cf3  view
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf9 // Fallback on earlier versions
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \cf4 func\cf3  mapView(\cf4 _\cf3  mapView: \cf6 MKMapView\cf3 , regionDidChangeAnimated animated: \cf5 Bool\cf3 ) \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf11 print\cf3 (\cf10 "region changed"\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 _\cf3  = \ulth m\ulnone ap.visibleMapRect
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  a = \ulth m\ulnone ap.annotations(in: map.visibleMapRect)
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  pins = \cf5 Array\cf3 (a.filter\{$0 \cf4 is\cf3  \cf6 MKAnnotation\cf3 \}) \cf4 as\cf3 ! [\cf6 MKAnnotation\cf3 ]
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf9 //var allVisible = true
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  delta = \ulth m\ulnone ap.region.span.latitudeDelta
\f0\fs24 \cf0 \

\f1\fs26 \cf3         print(\cf10 "PINS: \cf3 \\\cf10 (\cf3 pins.count\cf10 ), DELTA: \cf3 \\\cf10 (\cf3 delta\cf10 )"\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf9 //if pins.count > 20 \{ allVisible = false \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 if\cf3  pins.isEmpty \{ \cf4 return\cf3  \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 var\cf3  minimumDistance = \cf7 100000.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 var\cf3  minPin1 = \cf10 ""
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 var\cf3  minPin2 = \cf10 ""
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 for\cf3  pin1 \cf4 in\cf3  pins \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf9 //print("Checking for \\(pin1)")
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 for\cf3  pin2 \cf4 in\cf3  pins \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf4 let\cf3  lat = pin1.coordinate.latitude - pin2.coordinate.latitude
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf4 let\cf3  lon = pin1.coordinate.longitude - pin2.coordinate.longitude
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf4 if\cf3  lat == \cf7 0\cf3  && lon == \cf7 0\cf3  \{ \cf4 continue\cf3  \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf4 let\cf3  distance = sqrt(lat*lat + lon*lon)
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf4 if\cf3  distance < minimumDistance \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3                     minimumDistance = distance
\f0\fs24 \cf0 \

\f1\fs26 \cf3                     minPin1 = pin1.title!!
\f0\fs24 \cf0 \

\f1\fs26 \cf3                     minPin2 = pin2.title!!
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf9 //print(".... with \\(pin2) is \\(distance)")
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  ratio = \cf5 Int\cf3 (minimumDistance*\cf7 100\cf3 /delta)
\f0\fs24 \cf0 \

\f1\fs26 \cf3         print(ratio, minPin1, minPin2)
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 if\cf3  ratio > \cf7 20\cf3  \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf11 print\cf3 (\cf10 "
\f2 \uc0\u9989 
\f1 "\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 \ulth s\ulnone elf\cf3 .isShowingAllPins = \cf4 true
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 \ulth s\ulnone elf\cf3 .zoomInLabel.isHidden = \cf4 true
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \} \cf4 else\cf3  \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf11 print\cf3 (\cf10 "
\f2 \uc0\u10060 
\f1 "\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 \ulth s\ulnone elf\cf3 .isShowingAllPins = \cf4 false
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 \ulth s\ulnone elf\cf3 .zoomInLabel.isHidden = \cf4 false
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 for\cf3  av \cf4 in\cf3  \cf4 \ulth s\ulnone elf\cf3 .mapAnnotationViews \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             av.alpha = isShowingAllPins ? \cf7 1.00\cf3  : \cf7 0.98
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \cf4 func\cf3  setParisRegion()\{
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  paris = \cf5 CLLocationCoordinate2D\cf3 (latitude: \cf7 41.38\cf3 , longitude: \cf7 2.17\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \ulth m\ulnone ap.setRegion(\cf5 MKCoordinateRegion\cf3 .init(center: paris, span: \cf5 MKCoordinateSpan\cf3 .init(latitudeDelta: \cf7 10.0\cf3 , longitudeDelta: \cf7 10.0\cf3 )), animated: \cf4 false\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \cf4 @IBAction\cf3  \cf4 func\cf3  searchMapAction(\cf4 _\cf3  sender: \cf6 UIButton\cf3 ) \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf8 searchMap\cf3 ()
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \cf4 func\cf3  searchMap()\{
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  searchText = \cf4 \ulth s\ulnone elf\cf3 .mapTextField.text ?? \cf10 ""
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 if\cf3  searchText.isEmpty \{ \cf4 return\cf3  \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  req = \cf6 MKLocalSearchRequest\cf3 ()
\f0\fs24 \cf0 \

\f1\fs26 \cf3         req.naturalLanguageQuery = searchText
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  search = \cf6 MKLocalSearch\cf3 (request: req)
\f0\fs24 \cf0 \

\f1\fs26 \cf3         
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 \ulth s\ulnone elf\cf3 .map.alpha = \cf7 0.4
\f0\fs24 \cf0 \

\f1\fs26 \cf3         search.\cf11 start\cf3 \{ response, \cf4 _\cf3  \cf4 in
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 \ulth s\ulnone elf\cf3 .map.alpha = \cf7 1.0
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 guard\cf3  \cf4 let\cf3  response = response \cf4 else\cf3  \{\cf4 return\cf3 \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  placemark = response.\cf5 mapItems\cf3 .\cf5 first\cf3 !.\cf5 placemark
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  coordinate = placemark.\cf5 coordinate
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 \ulth s\ulnone elf\cf3 .map.setRegion(\cf5 MKCoordinateRegion\cf3 .init(center: coordinate, span: \cf5 MKCoordinateSpan\cf3 .init(latitudeDelta: \cf7 0.009\cf3 , longitudeDelta: \cf7 0.009\cf3 )), animated: \cf4 true\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  dict = placemark.\cf5 \ulth \ulc5 a\ulnone ddressDictionary\cf3 !
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  street = (dict[\cf10 "Street"\cf3 ] \cf4 as\cf3 ? \cf5 String\cf3  ?? \cf10 "Unknown Street"\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  city = (dict[\cf10 "City"\cf3 ] \cf4 as\cf3 ? \cf5 String\cf3  ?? \cf10 " "\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  postal = (dict[\cf10 "ZIP"\cf3 ] \cf4 as\cf3 ? \cf5 String\cf3  ?? \cf10 " "\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf9 //let country = (dict["Country"] as? String ?? " ")
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  countryCode = (dict[\cf10 "CountryCode"\cf3 ] \cf4 as\cf3 ? \cf5 String\cf3  ?? \cf10 " "\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 \ulth \ulc4 s\ulnone elf\cf3 .mapResultLabel.isHidden = \cf4 false
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 \ulth s\ulnone elf\cf3 .mapResultLabel.text = \cf10 " "\cf3 +street + \cf10 " \\n "\cf3  + city + \cf10 ", "\cf3  + postal + \cf10 " "\cf3  + countryCode + \cf10 " "
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \cf4 @IBAction\cf3  \cf4 func\cf3  locationPressed(\cf4 _\cf3  sender: \cf4 Any\cf3 ) \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  animated = sender \cf4 as\cf3 ? \cf5 Bool\cf3  ?? \cf4 true
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  c = \ulth m\ulnone ap.userLocation.coordinate
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 if\cf3  \cf5 Int\cf3 (c.latitude) == \cf7 0\cf3  \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 self\cf3 .\cf8 setParisRegion\cf3 ()
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 return
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 else\cf3  \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \ulth m\ulnone ap.setRegion(\cf5 MKCoordinateRegion\cf3 .init(center: c, span: \cf5 MKCoordinateSpan\cf3 .init(latitudeDelta: \cf7 0.005\cf3 , longitudeDelta: \cf7 0.005\cf3 )), animated: animated)
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \cf9 /*
\f0\fs24 \cf0 \

\f1\fs26 \cf9      func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) \{
\f0\fs24 \cf0 \

\f1\fs26 \cf9      print("updated to: \\(locations[0])")
\f0\fs24 \cf0 \

\f1\fs26 \cf9      guard let userLocation = locations.first?.coordinate else \{ return \}
\f0\fs24 \cf0 \

\f1\fs26 \cf9      //map.centerCoordinate = userLocation
\f0\fs24 \cf0 \

\f1\fs26 \cf9      if map.centerCoordinate.latitude < 10.0 \{
\f0\fs24 \cf0 \

\f1\fs26 \cf9      map.setRegion(MKCoordinateRegion.init(center: userLocation, span: MKCoordinateSpan.init(latitudeDelta: 0.5, longitudeDelta: 0.5)), animated: true)
\f0\fs24 \cf0 \

\f1\fs26 \cf9      \}
\f0\fs24 \cf0 \

\f1\fs26 \cf9      \}*/
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \cf4 func\cf3  setupWelcome()\{
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 \ulth s\ulnone elf\cf3 .titleStack.isHidden = \cf4 true
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 \ulth s\ulnone elf\cf3 .inputsStack.isHidden = \cf4 true
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 \ulth s\ulnone elf\cf3 .welcomeStack.isHidden = \cf4 false
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \cf4 func\cf3  mapView(\cf4 _\cf3  mapView: \cf6 MKMapView\cf3 , didSelect view: \cf6 MKAnnotationView\cf3 ) \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 if\cf3  view.\cf5 alpha\cf3  < \cf7 1.0\cf3  \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \ulth m\ulnone ap.deselectAnnotation(view.annotation, animated: \cf4 false\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 var\cf3  span = \ulth m\ulnone ap.region.span
\f0\fs24 \cf0 \

\f1\fs26 \cf3             span.latitudeDelta *= \cf7 0.3
\f0\fs24 \cf0 \

\f1\fs26 \cf3             span.longitudeDelta *= \cf7 0.3
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 let\cf3  newRegion = \cf5 MKCoordinateRegion\cf3 (center: view.annotation!.coordinate, span: span)
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf6 UIView\cf3 .animate(withDuration: \cf7 0.35\cf3 , animations: \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf4 self\cf3 .map.region = newRegion
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \})
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \ulth d\ulnone elay(\cf7 0.5\cf3 )\{
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \cf4 if\cf3  \cf4 self\cf3 .isShowingAllPins \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3                     \cf4 self\cf3 .map.selectAnnotation(view.annotation!, animated: \cf4 true\cf3 )
\f0\fs24 \cf0 \

\f1\fs26 \cf3                 \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3             \cf4 return
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 let\cf3  title = view.\cf5 annotation\cf3 !.title!!
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 \ulth s\ulnone elf\cf3 .mapResultLabel.text = title
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 \ulth s\ulnone elf\cf3 .mapResultLabel.isHidden = \cf4 false
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \}
\f0\fs24 \cf0 \

\f1\fs26 \cf3     
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \cf4 func\cf3  mapView(\cf4 _\cf3  mapView: \cf6 MKMapView\cf3 , didDeselect view: \cf6 MKAnnotationView\cf3 ) \{
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 \ulth s\ulnone elf\cf3 .mapResultLabel.text = \cf10 ""
\f0\fs24 \cf0 \

\f1\fs26 \cf3         \cf4 \ulth s\ulnone elf\cf3 .mapResultLabel.isHidden = \cf4 true
\f0\fs24 \cf0 \

\f1\fs26 \cf3     \}}